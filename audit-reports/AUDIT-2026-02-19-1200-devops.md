# DevOps / Platform Engineer Audit Report

**Project:** DocVault  
**Scope:** `src/`, `convex/`, project root configuration  
**Date:** 2026-02-19T12:00  
**Auditor Role:** DevOps / Platform Engineer  

---

## Findings

### Observability & Logging

#### ğŸŸ¡ MEDIUM: Unstructured logging throughout codebase

All logging uses plain `console.error` / `console.warn` with concatenated strings. Production log aggregators (Datadog, CloudWatch, GCP Logging) cannot parse, search, or alert on these reliably.

**Locations:**
- `convex/http.ts:46` â€” `console.error("Error verifying webhook:", err)`
- `convex/email.ts:17-19` â€” `console.warn("RESEND_API_KEY not set â€” skipping invite email to", args.email)`
- `src/components/providers.tsx:25` â€” `console.error("Failed to sync user:", err)`

**Fix:** Adopt structured JSON logging (e.g., `pino` or a shared logger utility) with fields for `level`, `message`, `context`, `timestamp`. Example:
```js
logger.error({ err, webhook_event: eventType }, "Webhook verification failed");
```
**Risk:** In production, unstructured logs make it extremely difficult to set up alerts, filter by severity, or correlate errors across services.

---

#### ğŸŸ¡ MEDIUM: PII (email address) logged to console

`convex/email.ts:19` logs the recipient email address directly to console output.

```
console.warn("RESEND_API_KEY not set â€” skipping invite email to", args.email);
```

**Fix:** Redact or hash the email before logging: `args.email.replace(/(.{2}).*(@.*)/, '$1***$2')`.  
**Risk:** Violates data minimization principles (GDPR/CCPA). Log storage providers may retain PII indefinitely.

---

#### ğŸ”µ LOW: No critical business event logging

Key business operations produce no log output at all:
- Team creation/deletion (`convex/teams.ts`)
- Document creation/upload/deletion (`convex/documents.ts`, `convex/documentVersions.ts`)
- Member addition/removal/role changes (`convex/teams.ts`)
- Invite creation/acceptance (`convex/invites.ts`, `convex/users.ts`)

**Fix:** Add structured info-level logs for each mutation that changes business state, including actor ID, resource ID, and action taken.  
**Risk:** No audit trail for investigating issues, compliance gaps, or debugging user-reported problems.

---

### Error Handling & Resilience

#### ğŸ”´ HIGH: Resend email API call has no timeout or retry

`convex/email.ts:29` â€” `resend.emails.send(...)` makes an external HTTP call to the Resend API with no timeout, no retry logic, and no circuit breaker.

```typescript
await resend.emails.send({ from: fromEmail, to: args.email, ... });
```

**Fix:** Wrap with a timeout and implement retry with exponential backoff:
```typescript
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 10000);
try {
  await resend.emails.send({ ... }, { signal: controller.signal });
} finally {
  clearTimeout(timeout);
}
```
**Risk:** If Resend is slow or down, the Convex action will hang until it hits the platform timeout. Scheduled actions will silently fail with no retry.

---

#### ğŸ”´ HIGH: File upload fetch has no timeout

`src/components/upload-dialog.tsx:72-76` and `src/app/teams/[teamId]/page.tsx:79-83` perform file uploads via `fetch()` with no `AbortController` timeout.

```typescript
const result = await fetch(uploadUrl, {
  method: "POST",
  headers: { "Content-Type": file.type },
  body: file,
});
```

**Fix:** Add an `AbortController` with a reasonable timeout (e.g., 60s for large files):
```typescript
const controller = new AbortController();
const timeout = setTimeout(() => controller.abort(), 60000);
try {
  const result = await fetch(uploadUrl, { ..., signal: controller.signal });
} finally {
  clearTimeout(timeout);
}
```
**Risk:** A stalled network connection will leave the user stuck on "Uploading..." indefinitely with no way to recover.

---

#### ğŸ”´ HIGH: deleteTeam performs unbounded cascading work in a single mutation

`convex/teams.ts:216-264` â€” `deleteTeam` iterates and deletes all members, invites, documents, versions, and storage objects in a single Convex mutation. This is unbounded work.

```typescript
for (const doc of documents) {
  const versions = await ctx.db.query("documentVersions")...collect();
  for (const version of versions) {
    await ctx.storage.delete(version.storageId);
    await ctx.db.delete(version._id);
  }
  await ctx.db.delete(doc._id);
}
```

**Fix:** Break into a scheduled cascade â€” `deleteTeam` marks the team as `deleting`, then schedules a cleanup action that processes in batches.  
**Risk:** For teams with many documents/versions, this will exceed Convex's mutation time/bandwidth limits, causing the delete to fail mid-way and leave orphaned data.

---

### Configuration & Environment

#### ğŸ”´ HIGH: No env var validation at startup

`src/components/providers.tsx:11` uses the TypeScript non-null assertion `!` on `NEXT_PUBLIC_CONVEX_URL`:

```typescript
const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
```

If this variable is missing, the app will crash at runtime with a cryptic error rather than failing fast at startup with a clear message. Similarly, `convex/http.ts:13` checks `CLERK_WEBHOOK_SECRET` only when the webhook is called, not at startup.

**Fix:** Add a startup validation module that checks all required env vars and throws descriptive errors:
```typescript
const requiredEnvVars = ['NEXT_PUBLIC_CONVEX_URL', 'NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY'];
for (const key of requiredEnvVars) {
  if (!process.env[key]) throw new Error(`Missing required env var: ${key}`);
}
```
**Risk:** Missing configuration causes confusing runtime failures that are hard to diagnose in production.

---

#### ğŸ”´ HIGH: No health check endpoint

No `/health` or `/api/health` route exists. There are no API routes at all in `src/app/api/`.

**Fix:** Add `src/app/api/health/route.ts`:
```typescript
export async function GET() {
  return Response.json({ status: "ok", timestamp: Date.now() });
}
```
**Risk:** Load balancers, container orchestrators (K8s, ECS), and uptime monitors have no way to determine if the application is healthy. Unhealthy instances will continue receiving traffic.

---

### Performance & Scalability

#### ğŸŸ¡ MEDIUM: No pagination on any list query

Every list query in the Convex backend uses `.collect()` which returns all matching rows:
- `convex/documents.ts:34-37` â€” `documents.list`
- `convex/teams.ts:44-47` â€” `teams.list` (memberships)
- `convex/teams.ts:79-81` â€” `teams.getMembers`
- `convex/invites.ts:10-13` â€” `invites.listPending`
- `convex/documentVersions.ts:72-77` â€” `documentVersions.list`
- `convex/documents.ts:100-103` â€” `documents.remove` (fetching versions for deletion)

**Fix:** Implement cursor-based pagination using Convex's `.paginate()` API and update the UI to support load-more or infinite scroll.  
**Risk:** As data grows, queries will return increasingly large result sets, increasing latency and bandwidth consumption. Eventually they will hit Convex read limits.

---

#### ğŸŸ¡ MEDIUM: N+1 query pattern in multiple list handlers

Several list queries perform additional DB reads per item with no batching:

- `convex/documents.ts:39-56` â€” For each document: fetches creator + all versions
- `convex/teams.ts:49-55` â€” For each membership: fetches team
- `convex/teams.ts:84-89` â€” For each member: fetches user
- `convex/invites.ts:18-23` â€” For each invite: fetches inviter
- `convex/documentVersions.ts:81-86` â€” For each version: fetches uploader

**Fix:** For Convex specifically, consider denormalizing frequently-joined data or restructuring queries to minimize fan-out.  
**Risk:** Query latency grows linearly with the number of items. A team with 100 documents triggers 200+ DB reads per page load.

---

#### ğŸŸ¡ MEDIUM: No rate limiting on public-facing mutations

No rate limiting exists on any mutation:
- `teams.create` â€” Unlimited team creation
- `documents.create` â€” Unlimited document creation
- `documentVersions.generateUploadUrl` / `createVersion` â€” Unlimited file uploads
- `teams.addMember` â€” Unlimited invite sending (triggers emails)

**Fix:** Implement rate limiting at the Convex function level or via middleware. For invite emails, add per-user send quotas.  
**Risk:** Malicious or buggy clients can flood the system, exhaust resources, or rack up email sending costs.

---

### Deployment Signals

#### ğŸ”µ LOW: No Dockerfile or docker-compose

No `Dockerfile`, `docker-compose.yml`, or container-related configuration exists in the project root.

**Fix:** Add a multi-stage Dockerfile for the Next.js app:
```dockerfile
FROM node:22-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:22-alpine AS runner
RUN addgroup -g 1001 -S app && adduser -S app -u 1001
WORKDIR /app
COPY --from=builder --chown=app:app /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
USER app
EXPOSE 3000
CMD ["npm", "start"]
```
**Risk:** Cannot deploy to container-based platforms (K8s, ECS, Cloud Run) without manual Dockerfile creation.

---

#### ğŸ”µ LOW: No graceful SIGTERM handling

No shutdown handler exists for graceful termination in container environments.

**Fix:** Register a SIGTERM handler or rely on Next.js built-in graceful shutdown (available in production mode). Verify that in-flight requests complete before the process exits.  
**Risk:** Hard kills during rolling deployments may drop in-flight requests and corrupt partial operations.

---

### Next.js Specific

#### ğŸŸ¡ MEDIUM: next.config.ts is completely empty â€” no security headers

`next.config.ts` contains no configuration at all:

```typescript
const nextConfig: NextConfig = {
  /* config options here */
};
```

No security headers are set: no CSP, no HSTS, no X-Frame-Options, no X-Content-Type-Options, no Referrer-Policy, no Permissions-Policy.

**Fix:** Add security headers:
```typescript
const nextConfig: NextConfig = {
  async headers() {
    return [{
      source: '/(.*)',
      headers: [
        { key: 'X-Frame-Options', value: 'DENY' },
        { key: 'X-Content-Type-Options', value: 'nosniff' },
        { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
        { key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubDomains; preload' },
        { key: 'Permissions-Policy', value: 'camera=(), microphone=(), geolocation=()' },
      ],
    }];
  },
};
```
**Risk:** Missing headers leave the application vulnerable to clickjacking, MIME-sniffing attacks, and protocol downgrade attacks.

---

#### ğŸ”µ LOW: No image domain allowlist in next.config.ts

Clerk user avatars (from `img.clerk.com` or similar CDN) are rendered via `<AvatarImage>` but `remotePatterns` is not configured in `next.config.ts`. While this currently works because `<img>` tags are used directly (not `next/image`), adopting `next/image` in the future will fail without an allowlist.

**Fix:** Proactively add `remotePatterns` for known image sources.  
**Risk:** Future adoption of `next/image` will break avatar rendering until domains are allowlisted.

---

#### ğŸ”µ LOW: Landing page could benefit from static generation

`src/app/page.tsx` is a server component with no dynamic data, making it an ideal candidate for static generation. Currently it renders on every request.

**Fix:** The page is already a server component without dynamic data, so Next.js should statically optimize it automatically. Verify by checking build output. If needed, add `export const dynamic = 'force-static'`.  
**Risk:** Unnecessary server-side rendering on every request for a page that never changes.

---

## Summary

| Severity | Count | Description |
|----------|-------|-------------|
| ğŸ”´ High | 5 | Will cause production incidents |
| ğŸŸ¡ Medium | 6 | Operational risk, fix soon |
| ğŸ”µ Low | 5 | Hardening / best practice |

### High Priority Fixes (Recommended Order)
1. Add health check endpoint (`/api/health`)
2. Add env var validation at startup
3. Add timeout to Resend API call
4. Add timeout to file upload fetch calls
5. Refactor deleteTeam to use batched/scheduled cascading deletes

### Medium Priority Fixes
1. Configure security headers in next.config.ts
2. Switch to structured JSON logging
3. Remove PII from log output
4. Add pagination to all list queries
5. Address N+1 query patterns
6. Implement rate limiting on mutations

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DEVOPS AUDIT â€” full project â€” 2026-02-19T12:00
   ğŸ”´ High: 5  ğŸŸ¡ Medium: 6  ğŸ”µ Low: 5
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
